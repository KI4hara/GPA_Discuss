<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src * data: gap: content: https://ssl.gstatic.com; style-src * 'unsafe-inline'; script-src * 'unsafe-inline' 'unsafe-eval'">
    <script src="components/loader.js"></script>
    <link rel="stylesheet" href="components/loader.css">
    <link rel="stylesheet" href="css/style.css">  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/onsenui/css/onsenui.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/onsenui/css/onsen-css-components.min.css">
    <script src="https://cdn.jsdelivr.net/npm/onsenui/js/onsenui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> <!-- Chart.jsライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0"></script>
<style>
    body {
        background-color: #121212;
        color: #ffffff;
    }
    .toolbar-img {
      width: 1200px; /* 幅を指定 */
      height: auto; /* 高さを自動調整 */
      max-width: 100%; /* 親要素の幅を超えないように */
    }

    /* Onsen UI のツールバー内の画像調整 */
    /* ツールバーの高さを調整 */
    ons-toolbar {
      height: 880px; /* 高さを指定 */
      line-height: 380px; /* テキストの中央揃え */
      padding: 0 20px; /* 内部の余白を調整 */
    }

    /* 画像のサイズ調整 */
    .toolbar-img {
      height: 50px; /* 高さを指定 */
      width: auto;  /* 幅は自動調整 */
    }

    /* ツールバー内での中央揃え */
    ons-toolbar__center {
      text-align: center;
      flex: 1;
    }


    ons-list-item {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px 0;
    }
    #response {
        white-space: pre-wrap;
        color: #000000;
        max-height: 300px; /* 最大高さを設定 */
        overflow-y: auto;  /* スクロールバー表示 */
    }
    #network {
        width: 100%;
        height: 400px;
        border: 1px solid lightgray;
    }
    #userChart, #summaryChart {
        width: 100%;
        height: 200px;
    }
    .center {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    ons-input, ons-select {
        width: 90%;
        max-width: 300px;
    }
    .hidden {
        display: none;
    }
</style>

</head>
<body>
    <ons-page>
        <ons-toolbar>
<img src="nunn.png" alt="Description of SVG" class="toolbar-img">

        </ons-toolbar>

        <div style="padding: 10px">
            <ons-list-item>
                    <div class="center">
                        <ons-button id="pcButton">パソコン用の人</ons-button>
                    </div>                        
                    <div class="left">                        
                        <ons-button id="evaluationButton">評価へ</ons-button>
                    </div>
                </ons-list-item>
            <ons-list>
                <ons-list-item id="discussionItem">
                    <div class="center">
                        <label for="discussionTopic">議論のテーマ:</label>
                        <ons-input id="discussionTopic" value="　" modifier="underbar"></ons-input>
                    </div>
                </ons-list-item>
                <ons-list-item id="teamItem" class="hidden">
                    <div class="center">
                        <label for="teamName">チーム:</label>
                        <ons-select id="team_letterSelect" onchange="showSelectedLetter()">
                            <option value="team1" selected>賛成</option>
                            <option value="team2">反対</option>
                        </ons-select>
                    </div>
                </ons-list-item>
                <ons-list-item id="userItem" class="hidden">
                    <div class="center">
                        <label for="userName">名前:</label>
                        <ons-select id="user_letterSelect" onchange="showSelectedLetter()">
                            <option value="A" selected>A</option>
                            <option value="B">B</option>
                            <option value="C">C</option>
                            <option value="D">D</option>
                            <option value="E">E</option>
                            <option value="F">F</option>
                            <option value="G">G</option>
                        </ons-select>
                    </div>
                </ons-list-item>
                <ons-list-item id="roleItem">
                    <div class="center">
                        <label for="roleSelect">役割:</label>
                        <ons-select id="roleSelect" onchange="updateVisibility()">
                            <option value="organizer" selected>主催者</option>
                            <option value="participant">参加者</option>
                        </ons-select>
                    </div>
                </ons-list-item>
                <ons-list-item id="downloadItem">
                    <div class="center">
                        <ons-button id="downloadBtn">JSON download</ons-button>
                    </div>
                </ons-list-item>
                <ons-list-item id="startButtonItem" class="hidden">
                    <div class="center">
                        <ons-button id="startButton">音声認識を開始</ons-button>
                    </div>
                </ons-list-item>
                <ons-list-item>
                    <div id="result" class="center"></div>
                </ons-list-item>
                <ons-list-item>
                    <div id="response" class="center"></div>
                </ons-list-item>
            </ons-list>
            
            <canvas id="userChart"></canvas>
            <canvas id="summaryChart"></canvas>
            <div id="network"></div>
        </div>
    </ons-page>
  <script src="https://cdn.jsdelivr.net/npm/onsenui/js/onsenui.min.js"></script>
    <script>

document.addEventListener('DOMContentLoaded', function () {
    const pcButton = document.getElementById('pcButton');
    pcButton.addEventListener('click', function () {
        window.location.href = 'https://direct-preview-66a8521ae78885f47cf37377.monaca.education';
    });

        const evaluationButton = document.getElementById('evaluationButton');
        evaluationButton.addEventListener('click', function () {
            window.location.href = 'https://direct-preview-66a76552e788858358b81656.monaca.education';
        });    
});
function updateVisibility() {
    const role = document.getElementById('roleSelect').value;
    const discussionItem = document.getElementById('discussionItem');
    const teamItem = document.getElementById('teamItem');
    const userItem = document.getElementById('userItem');
    const startButtonItem = document.getElementById('startButtonItem');
    const downloadItem = document.getElementById('downloadItem');

    if (role === 'organizer') {
        discussionItem.classList.remove('hidden');
        teamItem.classList.add('hidden');
        userItem.classList.add('hidden');
        startButtonItem.classList.add('hidden');
        downloadItem.classList.remove('hidden');
    } else if (role === 'participant') {
        discussionItem.classList.add('hidden');
        teamItem.classList.remove('hidden');
        userItem.classList.remove('hidden');
        startButtonItem.classList.remove('hidden');
        downloadItem.classList.add('hidden');
    }
}

// Initialize visibility based on the default role
document.addEventListener('DOMContentLoaded', updateVisibility);
//ドロップボックスの選択関数
        let selectedLetter;
        function showSelectedLetter() {
            selectedLetter = document.getElementById('user_letterSelect').value;
        }

//worldtimeapiからタイムスタンプを得る関数
async function fetchJapanTime() {
            try {
                const response = await fetch('https://www.timeapi.io/api/Time/current/zone?timeZone=Asia/Tokyo');
                //const response = await fetch('https://worldtimeapi.org/api/timezone/Asia/China');
                const data = await response.json();
                return data.dateTime;
            } catch (error) {
                console.error('Error fetching Japan time:', error);
                return null;
            }
        }

//音声認識
        document.addEventListener('DOMContentLoaded', async function() {
            const startButton = document.getElementById('startButton');
            const result = document.getElementById('result');
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            recognition.lang = 'ja-JP';
            recognition.interimResults = false;
            let recognizing = false;
            let speechStartTime;
            let speechEndTime;

            startButton.addEventListener('click', () => {
                if (recognizing) {
                    recognition.stop();
                    result.textContent = 'Recognition stopped.';
                    recognizing = false;
                    startButton.textContent = 'Start';
                } else {
                    recognition.start();
                    result.textContent = 'Listening...';
                    recognizing = true;
                    startButton.textContent = 'Stop';
                }
            });

            recognition.addEventListener('result', async (event) => {
                const transcript = event.results[0][0].transcript;
                result.textContent = `${transcript}`;
                speechEndTime = await fetchJapanTime(); // 発話終了時間を日本時間で記録
                const timeDifference = new Date(speechEndTime) - new Date(speechStartTime); // 時間差を計算
                send_voice(transcript, speechStartTime, speechEndTime, timeDifference);
            });

            recognition.addEventListener('speechstart', async () => {
                speechStartTime = await fetchJapanTime(); // 発話開始時間を日本時間で記録
            });

            recognition.addEventListener('error', (event) => {
                result.textContent = `Error occurred in recognition: ${event.error}`;
            });

            recognition.addEventListener('end', () => {
                if (recognizing) {
                    recognition.start();
                }
            });
        });

//MQTT通信
        var hyouzi = '';
        let broker = {
            hostname: 'takataka.msep.jp/mqtt/',
  port: 1883
            //hostname: 'ai-server.msep.jp/mqtt/',
            //port: 80
        };
        let client;
        const myId = crypto.randomUUID();
        let creds = { 
            clientID: myId,
            userName: 'iot',
            password: 'iot-school'
        }
        let topic2 = "okada_LED";
        let topic3 = "shitake2-voice";
        let topic4 = "shitake2-photo-recieve"

        client = new Paho.MQTT.Client(broker.hostname, Number(broker.port), creds.clientID);
        client.onMessageArrived = onMessageArrived;

        let jsonArray = [];
        let jsonArray_2 = [];
        let tempJsonArray = [];
        let currentUser = null;

        client.connect({
            onSuccess: onConnect,
            userName: creds.userName,
            password: creds.password,
            useSSL: true
        });

        function onConnect() {
            console.log("MQTTブローカーに接続しました");
            client.subscribe(topic4);
        }

//MQTTのレスポンス
        function onMessageArrived(message) { 
            console.log(message.payloadString);
            console.log(message.destinationName);
            const data = JSON.parse(message.payloadString);

            jsonArray.push(data);

            const user = data.User;
            const voice = data.Voice;
            const preTime = data.preTime;
            const endTime = data.endTime;
            const voiceTime = data.voiceTime;

            if (currentUser === null) {
                currentUser = user;
                tempJsonArray.push(data);
            } else if (currentUser === user) {
                tempJsonArray.push(data);
            } else {
                saveTempJsonArray(tempJsonArray);
                tempJsonArray = [data];
                currentUser = user;
            }

            hyouzi += user + ":" + voice  + '\n';
            document.getElementById('response').textContent = hyouzi;
           // plotUserTalkingTime(jsonArray);
        }

//同一userの会話を結合する関数
async function saveTempJsonArray(tempJsonArray) {
            if (tempJsonArray.length > 0) {
                let user = tempJsonArray[0].User;
                let preTime = tempJsonArray[0].preTime;
                let endTime = tempJsonArray[tempJsonArray.length - 1].endTime;
                let totalVoiceTime = tempJsonArray.reduce((acc, item) => acc + item.voiceTime, 0);
                let combinedVoice = tempJsonArray.map(item => item.Voice).join(' ');
                const sentimentResult = await analyzeSentiment(combinedVoice);

                let finalData = {
                    User: user,
                    Voice: combinedVoice,
                    preTime: preTime,
                    endTime: endTime,
                    voiceTime: totalVoiceTime,
                    sentiment: sentimentResult.documentSentiment
                };
                jsonArray_2.push(finalData);
                updateNetworkGraph(jsonArray_2);
                plotUserTalkingTime(jsonArray_2);
                //drawBarChart(); // 発言時間の棒グラフを更新
            }
        }

//MQTTを送信する関数
       async function send_voice(recordedVoice, startTime, endTime, timeDifference) {
            const japanTime = await fetchJapanTime();  
            var teamName = document.getElementById('team_letterSelect').value;
            var userName = document.getElementById('user_letterSelect').value;

            if (!recordedVoice) {
                alert("音声を提供してください");
                return;
            }

            console.log("Time:", japanTime);
            console.log("Team:", teamName);
            console.log("User:", userName);
            console.log("Voice:", recordedVoice);

            const data = {
                "Time": japanTime,
                "preTime": startTime,
                "endTime": endTime,
                "voiceTime": timeDifference,
                "Team": teamName,
                "User": userName,
                "Voice": recordedVoice
            };

            const jsonString = JSON.stringify(data);
            var message = new Paho.MQTT.Message(jsonString);
            message.destinationName = topic3;
            client.send(message);

            console.log("メッセージを送信しました");
        }

//感情分析を行う関数（GoogleAPI）
async function analyzeSentiment(text) {
            const apiKey = ''; // ここにAPIキーを追加
            const url = `https://language.googleapis.com/v1/documents:analyzeSentiment?key=${apiKey}`;
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    document: {
                        type: 'PLAIN_TEXT',
                        content: text,
                    },
                    encodingType: 'UTF8',
                }),
            });
            const data = await response.json();
            return data;
}



//グラフ関係
let chart = null;
let summaryChart = null;

function getColorForUser(user) {
    const userColors = {
        'A': 'rgba(75, 192, 192, 0.2)',
        'B': 'rgba(255, 99, 132, 0.2)',
        'C': 'rgba(54, 162, 235, 0.2)',
        'D': 'rgba(255, 206, 86, 0.2)',
        'E': 'rgba(153, 102, 255, 0.2)',
        'F': 'rgba(255, 159, 64, 0.2)',
        'G': 'rgba(100, 181, 246, 0.2)'
    };
    const userBorderColors = {
        'A': 'rgba(75, 192, 192, 1)',
        'B': 'rgba(255, 99, 132, 1)',
        'C': 'rgba(54, 162, 235, 1)',
        'D': 'rgba(255, 206, 86, 1)',
        'E': 'rgba(153, 102, 255, 1)',
        'F': 'rgba(255, 159, 64, 1)',
        'G': 'rgba(100, 181, 246, 1)'
    };

    return {
        backgroundColor: userColors[user] || 'rgba(201, 203, 207, 0.2)', // デフォルト色
        borderColor: userBorderColors[user] || 'rgba(201, 203, 207, 1)'  // デフォルト色
    };
}

//会話の時系列グラフ
function plotUserTalkingTime(dataArray) {
    const users = dataArray.map(data => data.User);
    const labels = dataArray.map(data => data.preTime);
    const talkingTimes = dataArray.map(data => data.voiceTime / 1000);

    console.log(users);
    console.log(labels);
    console.log(talkingTimes);

    if (chart !== null) {
        chart.destroy();
    }

    const backgroundColors = users.map(user => getColorForUser(user).backgroundColor);
    const borderColors = users.map(user => getColorForUser(user).borderColor);

    const ctx = document.getElementById('userChart').getContext('2d');
    chart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: '発言時刻',
                data: talkingTimes,
                backgroundColor: backgroundColors,
                borderColor: borderColors,
                borderWidth: 1
            }]
        },
        options: {
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: 'second',
                        tooltipFormat: 'HH:mm:ss',
                        displayFormats: {
                            second: 'HH:mm:ss'
                        }
                    },
                    title: {
                        display: true,
                        text: 'Time'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Talking Time (seconds)'
                    },
                    beginAtZero: true
                }
            }
        }
    });

    plotUserSummary(dataArray);
}

//総発話時間のグラフ
function plotUserSummary(dataArray) {
    // ユーザーごとの総発話時間を計算
    const userSummary = {};
    dataArray.forEach(data => {
        if (!userSummary[data.User]) {
            userSummary[data.User] = 0;
        }
        userSummary[data.User] += data.voiceTime / 1000;
    });

    const users = Object.keys(userSummary);
    const totalTalkingTimes = Object.values(userSummary);

    const backgroundColors = users.map(user => getColorForUser(user).backgroundColor);
    const borderColors = users.map(user => getColorForUser(user).borderColor);

    if (summaryChart !== null) {
        summaryChart.destroy();
    }

    const ctx = document.getElementById('summaryChart').getContext('2d');
    summaryChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: users,
            datasets: [{
                label: '総発話時間',
                data: totalTalkingTimes,
                backgroundColor: backgroundColors,
                borderColor: borderColors,
                borderWidth: 1
            }]
        },
        options: {
            indexAxis: 'y', // 横棒グラフにするためのオプション
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Total Talking Time (seconds)'
                    },
                    beginAtZero: true
                },
                y: {
                    title: {
                        display: true,
                        text: 'User'
                    }
                }
            }
        }
    });
}

//会話のネットワーク図を表示する関数
function updateNetworkGraph(jsonArray_2) {
    let nodes = [];
    let edges = [];
    let edgesMap = {};

    console.log(jsonArray_2);

    // ユーザーごとの発話回数と感情スコアの合計を計算
    const userSpeechDataMap = jsonArray_2.reduce((acc, entry) => {
        const user = entry.User;
        if (!acc[user]) {
            acc[user] = { speechCount: 0, sentimentSum: 0 };
        }
        acc[user].speechCount += 1;
        acc[user].sentimentSum += entry.sentiment.score;
        return acc;
    }, {});

    const maxSpeechCount = Math.max(...Object.values(userSpeechDataMap).map(data => data.speechCount));

    jsonArray_2.forEach(entry => {
        if (!nodes.find(node => node.id === entry.User)) {
            const speechCount = userSpeechDataMap[entry.User].speechCount;
            const nodeSize = (speechCount / maxSpeechCount) * 50; // 最大サイズを50に設定
            nodes.push({ id: entry.User, label: `${entry.User} (${speechCount})`, value: nodeSize });
        }

        const currentPreTime = new Date(entry.preTime).getTime();

        jsonArray_2.forEach(previousEntry => {
            if (entry.User !== previousEntry.User) {
                const previousEndTime = new Date(previousEntry.endTime).getTime();
                const timeDiff = currentPreTime - previousEndTime;
                const THIRTY_SECONDS = 30000; // 30秒の閾値（ミリ秒）

                if (timeDiff > 0 && timeDiff <= THIRTY_SECONDS) {
                    console.log(timeDiff);
                    const weight = (THIRTY_SECONDS - timeDiff) / THIRTY_SECONDS;
                    const edgeId = `${previousEntry.User}->${entry.User}`;

                    if (edgesMap[edgeId]) {
                        edgesMap[edgeId].value += weight;
                        edgesMap[edgeId].sentimentSum += entry.sentiment.score;
                        edgesMap[edgeId].count += 1;
                    } else {
                        edgesMap[edgeId] = { from: entry.User, to: previousEntry.User, value: weight, sentimentSum: entry.sentiment.score, count: 1 };
                    }
                }
            }
        });
    });

    edges = Object.values(edgesMap);
    const maxWeight = Math.max(...edges.map(edge => edge.value), 6); // 最大の重み（6で制限）

    edges.forEach(edge => {
        edge.value = Math.min(edge.value / maxWeight * 6, 6); // エッジの太さを計算し、最大値を6に制限
        const sentimentScore = edge.sentimentSum / edge.count; // センチメントスコアの平均値
        console.log(sentimentScore);

        const color = getGradientColor(sentimentScore);
        edge.color = { color };
    });

    const container = document.getElementById('network');
    const data = {
        nodes: new vis.DataSet(nodes),
        edges: new vis.DataSet(edges)
    };
    const options = {
        edges: {
            arrows: {
                to: {
                    enabled: true,
                    scaleFactor: 0.5
                }
            },
            smooth: {
                enabled: true,
                type: 'continuous'
            },
            color: {
                //color: '#848484',
                //highlight: '#FF0000'
            },
            width: 1
        },
        layout: {
            improvedLayout: true,
            hierarchical: false
        },
        physics: {
            enabled: true,
            solver: 'forceAtlas2Based',
            forceAtlas2Based: {
                gravitationalConstant: -50,
                centralGravity: 0.01,
                springLength: 200,
                springConstant: 0.05
            }
        }
    };
    new vis.Network(container, data, options);

    // ノードとエッジ情報をJSONに格納
    const networkData = {
        network: {
            nodes: nodes,
            edges: edges
        }
    };

    let network_JSON = JSON.stringify(data, null, 2);

    // JSONファイルをダウンロード
    function downloadJSON(data, filename = 'network_data.json') {
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    document.getElementById('downloadBtn').onclick = () => downloadJSON(networkData);
}

//エッジを感情分析の結果で青ー１、赤＋１とする関数
function getGradientColor(score) {
    const normalizedScore = (score + 1) / 2; // スコアを0から1の範囲に正規化
    const red = Math.round(normalizedScore * 255).toString(16).padStart(2, '0');
    const blue = Math.round((1 - normalizedScore) * 255).toString(16).padStart(2, '0');
    return `#${red}00${blue}`;
}

//会話履歴のjsonをダウンロードする関数 
document.addEventListener('DOMContentLoaded', function () {
    document.getElementById('downloadBtn').addEventListener('click', function () {
        try {
            saveTempJsonArray();

           let theme = document.getElementById('discussionTopic').value;

            // JSONデータを作成
            const jsonData1 = {
                theme: theme,
                dialogue: jsonArray
            };

            const jsonData2 = {
                theme: theme,
                dialogue: jsonArray_2
            };

            // Create blob and URL for original_data.json
            const blob1 = new Blob([JSON.stringify(jsonData1, null, 2)], { type: 'application/json' });
            const url1 = URL.createObjectURL(blob1);
            const a1 = document.createElement('a');
            a1.href = url1;
            a1.download = 'original_data.json';
            document.body.appendChild(a1);
            a1.click();
            document.body.removeChild(a1);
            URL.revokeObjectURL(url1);

            // Create blob and URL for aggregated_data.json
            const blob2 = new Blob([JSON.stringify(jsonData2, null, 2)], { type: 'application/json' });
            const url2 = URL.createObjectURL(blob2);
            const a2 = document.createElement('a');
            a2.href = url2;
            a2.download = 'aggregated_data.json';
            document.body.appendChild(a2);
            a2.click();
            document.body.removeChild(a2);
            URL.revokeObjectURL(url2);
        } catch (error) {
            console.error('Error generating JSON file:', error);
        }
    });
});


    </script>
</body>